"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8843],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>k});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var s=a.createContext({}),p=function(e){var t=a.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(r),d=n,k=c["".concat(s,".").concat(d)]||c[d]||m[d]||i;return r?a.createElement(k,o(o({ref:t},u),{},{components:r})):a.createElement(k,o({ref:t},u))}));function k(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:n,o[1]=l;for(var p=2;p<i;p++)o[p]=r[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},3837:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=r(7462),n=(r(7294),r(3905));const i={sidebar_position:3},o="Ray",l={unversionedId:"Shakudo-stack/distributedComputing/ray",id:"Shakudo-stack/distributedComputing/ray",title:"Ray",description:"Ray is an open source project that distributed frameworks that has a more support for deep learning and reinforcement learning. It has a rich set of libraries and integrations built on a flexible distributed execution framework, is ideal choice for parallelizing model training and hyper-parameter tuning.",source:"@site/docs/Shakudo-stack/distributedComputing/ray.md",sourceDirName:"Shakudo-stack/distributedComputing",slug:"/Shakudo-stack/distributedComputing/ray",permalink:"/Shakudo-stack/distributedComputing/ray",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Dask",permalink:"/Shakudo-stack/distributedComputing/dask"},next:{title:"Apache Spark",permalink:"/Shakudo-stack/distributedComputing/spark"}},s={},p=[{value:"Ray_Common",id:"ray_common",level:2},{value:"<code>quickstart_ray()</code>",id:"quickstart_ray",level:2},{value:"<code>initialize_ray_cluster()</code>",id:"initialize_ray_cluster",level:2},{value:"<code>stop_ray_cluster()</code>",id:"stop_ray_cluster",level:2},{value:"<code>get_ray_cluster()</code>",id:"get_ray_cluster",level:2},{value:"<code>find_ray_workers</code>",id:"find_ray_workers",level:2}],u={toc:p},c="wrapper";function m(e){let{components:t,...r}=e;return(0,n.kt)(c,(0,a.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"ray"},"Ray"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://ray.io/"},"Ray")," is an open source project that distributed frameworks that has a more support for deep learning and reinforcement learning. It has a rich set of libraries and integrations built on a flexible distributed execution framework, is ideal choice for parallelizing model training and hyper-parameter tuning."),(0,n.kt)("h2",{id:"ray_common"},"Ray_Common"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"ray_common")," is part of the Shakudo Platform Hyperplane API that contains convenience functions to manage Ray clusters. We support extensions to the basic Ray framework by supporting Ray Tune, Ray Spark, Ray with RAPIDS, and more."),(0,n.kt)("h2",{id:"quickstart_ray"},(0,n.kt)("inlineCode",{parentName:"h2"},"quickstart_ray()")),(0,n.kt)("p",null,"Use ",(0,n.kt)("inlineCode",{parentName:"p"},"quickstart_ray")," to quickly spin up a Ray cluster using ",(0,n.kt)("a",{parentName:"p",href:"/Shakudo-stack/distributedComputing/dask"},"t-shirt sizes")," (Sizes are the same as quick start for Dask clusters)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from hyperplane import ray_common as rc\nray_cluster = rc.quickstart_ray(\n    num_workers = 4, \n    size = 'hyperplane-med-high-mem'\n)\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"num_workers   ",(0,n.kt)("div",{class:"label basic required"},"Required")),(0,n.kt)("td",{parentName:"tr",align:"left"},"integer"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Number of workers")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"size          ",(0,n.kt)("div",{class:"label basic required"},"Required")),(0,n.kt)("td",{parentName:"tr",align:"left"},"object"),(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("a",{parentName:"td",href:"#worker-pools"},"Pre-configured worker pools"))))),(0,n.kt)("hr",null),(0,n.kt)("a",{name:"initialize-ray-cluster"}),(0,n.kt)("h2",{id:"initialize_ray_cluster"},(0,n.kt)("inlineCode",{parentName:"h2"},"initialize_ray_cluster()")),(0,n.kt)("p",null,"Initialize a distributed Ray cluster with ease and more customizability. You can also run this function to clean up the Ray nodes and re-initialize."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from hyperplane import ray_common as rc\nray_cluster = rc.initialize_ray_cluster(\n    num_workers = 4, \n    cpu_core_per_worker = 4, \n    ram_gb_per_worker = 4, \n    n_gpus = 0\n    )\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"}," Parameters ")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"num_workers"),(0,n.kt)("td",{parentName:"tr",align:"left"},"integer"),(0,n.kt)("td",{parentName:"tr",align:"left"},"(Default value: 2) Number of Ray nodes to be initialized")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"cpu_core_per_worker"),(0,n.kt)("td",{parentName:"tr",align:"left"},"integer"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Number of CPU cores in each Ray node")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"ram_gb_per_worker"),(0,n.kt)("td",{parentName:"tr",align:"left"},"float"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Memory size in GB for each Ray node")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"n_gpus"),(0,n.kt)("td",{parentName:"tr",align:"left"},"integer"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Number of Nvidia GPUs in each Ray node (if ",(0,n.kt)("inlineCode",{parentName:"td"},"n_gpus > 0"),", ",(0,n.kt)("inlineCode",{parentName:"td"},"cpu_core_per_worker")," and ",(0,n.kt)("inlineCode",{parentName:"td"},"ram_gb_per_worker")," are ignored)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"use_existing"),(0,n.kt)("td",{parentName:"tr",align:"left"},"boolean"),(0,n.kt)("td",{parentName:"tr",align:"left"},"(Default: ",(0,n.kt)("inlineCode",{parentName:"td"},"use_existing = False"),") Whether to connect to/ reinitialize existing Ray cluster or spin up a new one")))),(0,n.kt)("admonition",{type:"note"},(0,n.kt)("p",{parentName:"admonition"},"If you are aiming for a specific pool, ensure your ",(0,n.kt)("inlineCode",{parentName:"p"},"cpu_core_per_worker")," = the number of allocatable cores and ",(0,n.kt)("inlineCode",{parentName:"p"},"ram_gb_per_worker")," = the allocatable ram. For example, if you would like to use a POOL_16_16 worker, you may want to use the following cluster initialization."),(0,n.kt)("pre",{parentName:"admonition"},(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from hyperplane import ray_common as rc\nray_cluster = rc.initialize_ray_cluster(\n    num_workers = 4, \n    cpu_core_per_worker = 15, \n    ram_gb_per_worker = 12\n    )\n"))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"stop_ray_cluster"},(0,n.kt)("inlineCode",{parentName:"h2"},"stop_ray_cluster()")),(0,n.kt)("p",null,"Use ",(0,n.kt)("inlineCode",{parentName:"p"},"stop_ray_cluster")," to shutdown a Ray cluster. After computation is finished, it's a good idea to shutdown the distributed cluster and release the resources back to the node pool. If any Ray nodes are left hanging, Shakudo Platform's garbage collection function will also automatically shutdown the Ray workers when the Session or job is finished. "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from hyperplane import ray_common as rc\nrc.stop_ray_cluster(ray_cluster)\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"}," Parameters ")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"ray_cluster ",(0,n.kt)("div",{class:"label basic required"},"Required")),(0,n.kt)("td",{parentName:"tr",align:"left"},"object"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Ray cluster to shutdown")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"get_ray_cluster"},(0,n.kt)("inlineCode",{parentName:"h2"},"get_ray_cluster()")),(0,n.kt)("p",null,"Reconnect to a Ray cluster by using the ",(0,n.kt)("inlineCode",{parentName:"p"},"get_ray_cluster")," to retrieve the cluster. You can use this function if you've already spun up a Ray cluster and want to connect to the same cluster (for example: in another notebook in the same session). This function will connect to an existing cluster. There are two ways to reconnect to Ray clusters.  "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from hyperplane import ray_common as rc\nrc.get_ray_cluster(extra_workers = 1)\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"}," Parameters ")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},"extra_workers"),(0,n.kt)("td",{parentName:"tr",align:"left"},"integer"),(0,n.kt)("td",{parentName:"tr",align:"left"},"Adds nodes to your existing cluster (Default: ",(0,n.kt)("inlineCode",{parentName:"td"},"extra_workers = 0"),") The nodes that are added to the cluster will be of the same specification as the original cluster.")))),(0,n.kt)("p",null,"There are two ways to reconnect to Ray clusters. The method using the function ",(0,n.kt)("inlineCode",{parentName:"p"},"get_ray_cluster()")," is the simpler and recommended way. "),(0,n.kt)("p",null,"You can also use the ",(0,n.kt)("inlineCode",{parentName:"p"},"initialize_ray_cluster()")," to accomplish the same. Note, the arguments for ",(0,n.kt)("inlineCode",{parentName:"p"},"cpu_core_per_worker")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"ram_gb_per_worker")," must be the same as when you initialized the cluster originally."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from hyperplane import ray_common as rc\nray_cluster = rc.initialize_ray_cluster(\n    num_workers = 0, \n    cpu_core_per_worker = 15, \n    ram_gb_per_worker = 12,\n    use_existing = True\n    )\n")),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"find_ray_workers"},(0,n.kt)("inlineCode",{parentName:"h2"},"find_ray_workers")),(0,n.kt)("p",null,"Use ",(0,n.kt)("inlineCode",{parentName:"p"},"find_ray_workers()")," function to see if there are any Ray workers already spun up. Returns a list of Ray workers running."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"from hyperplane import ray_common as rc\nrc.find_ray_workers()\n")))}m.isMDXComponent=!0}}]);