"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6432],{3905:function(e,t,a){a.d(t,{Zo:function(){return T},kt:function(){return _}});var n=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=n.createContext({}),u=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},T=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,T=o(e,["components","mdxType","originalType","parentName"]),p=u(a),_=s,d=p["".concat(l,".").concat(_)]||p[_]||m[_]||r;return a?n.createElement(d,i(i({ref:t},T),{},{components:a})):n.createElement(d,i({ref:t},T))}));function _(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,i=new Array(r);i[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var u=2;u<r;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},1993:function(e,t,a){a.r(t),a.d(t,{assets:function(){return T},contentTitle:function(){return l},default:function(){return _},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return m}});var n=a(7462),s=a(3366),r=(a(7294),a(3905)),i=["components"],o={sidebar_position:10},l="GraphQL",u={unversionedId:"shakudo-platform-features/graphql",id:"shakudo-platform-features/graphql",title:"GraphQL",description:"Many of the Shakudo Platform features are supported through the platform dashboard as well as GraphQL. GraphQL method is particularly useful when some actions are easier done algorithmically such as spinning up many jobs at once.",source:"@site/docs/shakudo-platform-features/graphql.md",sourceDirName:"shakudo-platform-features",slug:"/shakudo-platform-features/graphql",permalink:"/shakudo-platform-features/graphql",draft:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"PodSpecs",permalink:"/shakudo-platform-features/podspecs"},next:{title:"FAQ",permalink:"/shakudo-platform-features/faq"}},T={},m=[{value:"Sessions",id:"sessions",level:2},{value:"Get Sessions",id:"get-sessions",level:3},{value:"Cancel a session by session_id",id:"cancel-a-session-by-session_id",level:3},{value:"Count sessions",id:"count-sessions",level:3},{value:"Create a pipeline job",id:"create-a-pipeline-job",level:3},{value:"Cancel a pipeline job",id:"cancel-a-pipeline-job",level:3},{value:"Get a list of jobs",id:"get-a-list-of-jobs",level:3},{value:"Get job status",id:"get-job-status",level:3},{value:"Get scheduled jobs status",id:"get-scheduled-jobs-status",level:3},{value:"Get a list of services",id:"get-a-list-of-services",level:3},{value:"Jobs",id:"jobs",level:2},{value:"Submit a pipeline job",id:"submit-a-pipeline-job",level:3},{value:"Cancel a job",id:"cancel-a-job",level:3},{value:"Cancel all scheduled jobs",id:"cancel-all-scheduled-jobs",level:3},{value:"Check the status of a job",id:"check-the-status-of-a-job",level:3},{value:"Get job parameters",id:"get-job-parameters",level:3},{value:"Detele job parameters",id:"detele-job-parameters",level:3},{value:"Update job parameters",id:"update-job-parameters",level:3}],p={toc:m};function _(e){var t=e.components,a=(0,s.Z)(e,i);return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"graphql"},"GraphQL"),(0,r.kt)("p",null,"Many of the Shakudo Platform features are supported through the platform dashboard as well as GraphQL. GraphQL method is particularly useful when some actions are easier done algorithmically such as spinning up many jobs at once."),(0,r.kt)("p",null,"Below are some common graphql queries for submission, checking status, etc. "),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"sessions"},"Sessions"),(0,r.kt)("h3",{id:"get-sessions"},"Get Sessions"),(0,r.kt)("p",null,"Get a list of Sessions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"query hyperhubSessions($limit: Int!, $email: String, $status: String, $imageType: String) {\n    hyperHubSessions(orderBy:{startTime: desc}, take: $limit, where: {\n      hyperplaneUserEmail: {equals: $email},\n      status: {equals: $status},\n    }) {\n      id\n      hyperplaneUserEmail\n      status\n      imageType\n      jLabUrl\n      notebookURI\n      estimatedCost\n      department\n      resourceCPUlimit    \n      resourceRAMlimit    \n      resourceCPUrequest  \n      resourceRAMrequest  \n      gpuRequest  \n      startTime\n      completionTime  \n    }\n    countHyperHubSessions\n  }\n")),(0,r.kt)("h3",{id:"cancel-a-session-by-session_id"},"Cancel a session by session_id"),(0,r.kt)("p",null,"Cancel a Session"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'mutation($id: String!) {\n  updateHyperHubSession(where: {id: $id}, data: {\n    status: {set: "cancelled"}\n  }) {\n    id\n    status\n  }\n}\n')),(0,r.kt)("h3",{id:"count-sessions"},"Count sessions"),(0,r.kt)("p",null,"Count the number of sessions based on the filters provided by the parameters"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"query hyperhubSessions($email: String, $imageType: String, $status: String) {\n  hyperHubSessions(where: {\n    hyperplaneUserEmail: {equals: $email},\n    imageType: {equals: $imageType}\n    status: {equals: $status}\n  }) {\n    id \n  }\n}\n")),(0,r.kt)("h3",{id:"create-a-pipeline-job"},"Create a pipeline job"),(0,r.kt)("p",null,"Create a pipeline job with the specified inputs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"mutation ($type: String!, $timeout: Int!, $activeTimeout: Int, $maxRetries: Int!, $yamlPath: String!, $exposedPort: String, $schedule: String, $parameters: ParameterCreateNestedManyWithoutPipelineJobInput ) { \n  createPipelineJob (data: {\n    jobType: $type,\n    timeout: $timeout,\n    activeTimeout: $activeTimeout\n    maxRetries: $maxRetries,\n    pipelineYamlPath: $yamlPath,\n    exposedPort: $exposedPort,\n    parameters: $parameters,\n    schedule: $schedule\n    }) { \n      id\n      pinned\n      pipelineYamlPath\n      schedule\n      status\n      statusReason\n      output\n      startTime\n      completionTime\n      daskDashboardUrl\n      timeout\n      outputNotebooksPath\n      activeTimeout\n      maxRetries\n      exposedPort\n      jobType\n      parameters {\n        key\n        value\n      }\n  } \n} \n")),(0,r.kt)("h3",{id:"cancel-a-pipeline-job"},"Cancel a pipeline job"),(0,r.kt)("p",null,"Cancel a job (Stop job from running)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'mutation ($id: String!) {\n  updatePipelineJob(where: {id: $id},\n  data: {\n    status: {set: "cancelled"}\n  }) {\n    id\n  }\n}\n')),(0,r.kt)("h3",{id:"get-a-list-of-jobs"},"Get a list of jobs"),(0,r.kt)("p",null,"Show the list of jobs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"query nextJobs($limit: Int!) {\n  pipelineJobs(orderBy: [{pinned: desc},{ startTime: desc}], take: $limit) {\n    id\n    pipelineYamlPath\n    schedule\n    status\n    output\n    startTime\n    completionTime\n    daskDashboardUrl\n    timeout\n    outputNotebooksPath\n    activeTimeout\n    maxRetries\n    jobType\n    estimatedCost\n    owner\n    department\n  }\n}\n")),(0,r.kt)("h3",{id:"get-job-status"},"Get job status"),(0,r.kt)("p",null,"Count the number of jobs based on their statuses. For example, failed, pending, or cancelled jobs.\nThe timeFrame parameter specifies the timeframe which will be considered."),(0,r.kt)("p",null,"For instance:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"T_10M = past 10 minutes"),(0,r.kt)("li",{parentName:"ul"},"T_24H = past 24 hours")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"query {\n  COUNT_ALL_TOTAL: getJobStat(stat: COUNT_ALL, timeFrame: TOTAL)\n  COUNT_CANCELLED_TOTAL: getJobStat(stat: COUNT_CANCELLED, timeFrame: TOTAL)\n  COUNT_DONE_TOTAL: getJobStat(stat: COUNT_DONE, timeFrame: TOTAL)\n  COUNT_FAILED_TOTAL: getJobStat(stat: COUNT_FAILED, timeFrame: TOTAL)\n  COUNT_IN_PROGRESS_TOTAL: getJobStat(\n    stat: COUNT_IN_PROGRESS\n    timeFrame: TOTAL\n  )\n  COUNT_PENDING_TOTAL: getJobStat(stat: COUNT_PENDING, timeFrame: TOTAL)\n  COUNT_SCHEDULED_TOTAL: getJobStat(stat: COUNT_SCHEDULED, timeFrame: TOTAL)\n  COUNT_TIMED_OUT_TOTAL: getJobStat(stat: COUNT_TIMED_OUT, timeFrame: TOTAL)\n  COUNT_ALL_T_10M: getJobStat(stat: COUNT_ALL, timeFrame: T_10M)\n  COUNT_CANCELLED_T_10M: getJobStat(stat: COUNT_CANCELLED, timeFrame: T_10M)\n  COUNT_DONE_T_10M: getJobStat(stat: COUNT_DONE, timeFrame: T_10M)\n  COUNT_FAILED_T_10M: getJobStat(stat: COUNT_FAILED, timeFrame: T_10M)\n  COUNT_IN_PROGRESS_T_10M: getJobStat(\n    stat: COUNT_IN_PROGRESS\n    timeFrame: T_10M\n  )\n  COUNT_PENDING_T_10M: getJobStat(stat: COUNT_PENDING, timeFrame: T_10M)\n  COUNT_SCHEDULED_T_10M: getJobStat(stat: COUNT_SCHEDULED, timeFrame: T_10M)\n  COUNT_TIMED_OUT_T_10M: getJobStat(stat: COUNT_TIMED_OUT, timeFrame: T_10M)\n  COUNT_ALL_T_1H: getJobStat(stat: COUNT_ALL, timeFrame: T_1H)\n  COUNT_CANCELLED_T_1H: getJobStat(stat: COUNT_CANCELLED, timeFrame: T_1H)\n  COUNT_DONE_T_1H: getJobStat(stat: COUNT_DONE, timeFrame: T_1H)\n  COUNT_FAILED_T_1H: getJobStat(stat: COUNT_FAILED, timeFrame: T_1H)\n  COUNT_IN_PROGRESS_T_1H: getJobStat(stat: COUNT_IN_PROGRESS, timeFrame: T_1H)\n  COUNT_PENDING_T_1H: getJobStat(stat: COUNT_PENDING, timeFrame: T_1H)\n  COUNT_SCHEDULED_T_1H: getJobStat(stat: COUNT_SCHEDULED, timeFrame: T_1H)\n  COUNT_TIMED_OUT_T_1H: getJobStat(stat: COUNT_TIMED_OUT, timeFrame: T_1H)\n  COUNT_ALL_T_24H: getJobStat(stat: COUNT_ALL, timeFrame: T_24H)\n  COUNT_CANCELLED_T_24H: getJobStat(stat: COUNT_CANCELLED, timeFrame: T_24H)\n  COUNT_DONE_T_24H: getJobStat(stat: COUNT_DONE, timeFrame: T_24H)\n  COUNT_FAILED_T_24H: getJobStat(stat: COUNT_FAILED, timeFrame: T_24H)\n  COUNT_IN_PROGRESS_T_24H: getJobStat(\n    stat: COUNT_IN_PROGRESS\n    timeFrame: T_24H\n  )\n  COUNT_PENDING_T_24H: getJobStat(stat: COUNT_PENDING, timeFrame: T_24H)\n  COUNT_SCHEDULED_T_24H: getJobStat(stat: COUNT_SCHEDULED, timeFrame: T_24H)\n  COUNT_TIMED_OUT_T_24H: getJobStat(stat: COUNT_TIMED_OUT, timeFrame: T_24H)\n}\n")),(0,r.kt)("h3",{id:"get-scheduled-jobs-status"},"Get scheduled jobs status"),(0,r.kt)("p",null,"Count the number of ",(0,r.kt)("em",{parentName:"p"},"scheduled")," jobs based on their statuses. For example, failed, pending, or cancelled jobs.\nThe differnece with the query above is that the belew parameter is added to only count scheduled jobs for each time frame with ",(0,r.kt)("inlineCode",{parentName:"p"},"status: SCHEDULED")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"query {\n  COUNT_ALL_TOTAL: getJobStat(stat: COUNT_ALL, timeFrame: TOTAL, status: SCHEDULED)\n  COUNT_CANCELLED_TOTAL: getJobStat(stat: COUNT_CANCELLED, timeFrame: TOTAL, status: SCHEDULED)\n  COUNT_DONE_TOTAL: getJobStat(stat: COUNT_DONE, timeFrame: TOTAL, status: SCHEDULED)\n  COUNT_FAILED_TOTAL: getJobStat(stat: COUNT_FAILED, timeFrame: TOTAL, status: SCHEDULED)\n  COUNT_IN_PROGRESS_TOTAL: getJobStat(\n    stat: COUNT_IN_PROGRESS\n    timeFrame: TOTAL\n  )\n  COUNT_PENDING_TOTAL: getJobStat(stat: COUNT_PENDING, timeFrame: TOTAL, status: SCHEDULED)\n  COUNT_SCHEDULED_TOTAL: getJobStat(stat: COUNT_SCHEDULED, timeFrame: TOTAL, status: SCHEDULED)\n  COUNT_TIMED_OUT_TOTAL: getJobStat(stat: COUNT_TIMED_OUT, timeFrame: TOTAL, status: SCHEDULED)\n  COUNT_ALL_T_10M: getJobStat(stat: COUNT_ALL, timeFrame: T_10M)\n  COUNT_CANCELLED_T_10M: getJobStat(stat: COUNT_CANCELLED, timeFrame: T_10M, status: SCHEDULED)\n  COUNT_DONE_T_10M: getJobStat(stat: COUNT_DONE, timeFrame: T_10M, status: SCHEDULED)\n  COUNT_FAILED_T_10M: getJobStat(stat: COUNT_FAILED, timeFrame: T_10M, status: SCHEDULED)\n  COUNT_IN_PROGRESS_T_10M: getJobStat(\n    stat: COUNT_IN_PROGRESS\n    timeFrame: T_10M\n  )\n  COUNT_PENDING_T_10M: getJobStat(stat: COUNT_PENDING, timeFrame: T_10M, status: SCHEDULED)\n  COUNT_SCHEDULED_T_10M: getJobStat(stat: COUNT_SCHEDULED, timeFrame: T_10M, status: SCHEDULED)\n  COUNT_TIMED_OUT_T_10M: getJobStat(stat: COUNT_TIMED_OUT, timeFrame: T_10M, status: SCHEDULED)\n  COUNT_ALL_T_1H: getJobStat(stat: COUNT_ALL, timeFrame: T_1H, status: SCHEDULED)\n  COUNT_CANCELLED_T_1H: getJobStat(stat: COUNT_CANCELLED, timeFrame: T_1H, status: SCHEDULED)\n  COUNT_DONE_T_1H: getJobStat(stat: COUNT_DONE, timeFrame: T_1H, status: SCHEDULED)\n  COUNT_FAILED_T_1H: getJobStat(stat: COUNT_FAILED, timeFrame: T_1H, status: SCHEDULED)\n  COUNT_IN_PROGRESS_T_1H: getJobStat(stat: COUNT_IN_PROGRESS, timeFrame: T_1H, status: SCHEDULED)\n  COUNT_PENDING_T_1H: getJobStat(stat: COUNT_PENDING, timeFrame: T_1H, status: SCHEDULED)\n  COUNT_SCHEDULED_T_1H: getJobStat(stat: COUNT_SCHEDULED, timeFrame: T_1H, status: SCHEDULED)\n  COUNT_TIMED_OUT_T_1H: getJobStat(stat: COUNT_TIMED_OUT, timeFrame: T_1H, status: SCHEDULED)\n  COUNT_ALL_T_24H: getJobStat(stat: COUNT_ALL, timeFrame: T_24H)\n  COUNT_CANCELLED_T_24H: getJobStat(stat: COUNT_CANCELLED, timeFrame: T_24H, status: SCHEDULED)\n  COUNT_DONE_T_24H: getJobStat(stat: COUNT_DONE, timeFrame: T_24H, status: SCHEDULED)\n  COUNT_FAILED_T_24H: getJobStat(stat: COUNT_FAILED, timeFrame: T_24H, status: SCHEDULED)\n  COUNT_IN_PROGRESS_T_24H: getJobStat(\n    stat: COUNT_IN_PROGRESS\n    timeFrame: T_24H\n    , status: SCHEDULED\n  )\n  COUNT_PENDING_T_24H: getJobStat(stat: COUNT_PENDING, timeFrame: T_24H, status: SCHEDULED)\n  COUNT_SCHEDULED_T_24H: getJobStat(stat: COUNT_SCHEDULED, timeFrame: T_24H, status: SCHEDULED)\n  COUNT_TIMED_OUT_T_24H: getJobStat(stat: COUNT_TIMED_OUT, timeFrame: T_24H, status: SCHEDULED)\n}\n")),(0,r.kt)("h3",{id:"get-a-list-of-services"},"Get a list of services"),(0,r.kt)("p",null,"Get list of services - services are pipeline jobs which have an active timeout and timeout of -1 (Never ending jobs)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"query nextJobs($offset: Int, $limit: Int!, $status: String!) {\n  pipelineJobs(orderBy: [{pinned: desc},{ startTime: desc}], take: $limit, skip: $offset, where: {\n    AND: [\n      {activeTimeout: {equals: -1}},\n      {timeout: {equals: -1}},\n      {status: {equals: $status}}\n    ]        \n  }) {\n    id\n    exposedPort\n    pinned\n    pipelineYamlPath\n    schedule\n    status\n    statusReason\n    startTime\n    completionTime\n    daskDashboardUrl\n    timeout\n    output\n    outputNotebooksPath\n    activeTimeout\n    duration\n    jobType\n    schedule\n    estimatedCost\n    owner\n    department\n    maxRetries\n  }\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"jobs"},"Jobs"),(0,r.kt)("h3",{id:"submit-a-pipeline-job"},"Submit a pipeline job"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'mutation submitJob { \n  createPipelineJob (data: {\n    jobType: "basic",\n    timeout: 1500,\n    activeTimeout: 1000,\n    maxRetries: 5,\n    pipelineYamlPath: "example_pipeline.yaml",\n    parameters: {\n      create: [\n        {key: "a_param", value: "pass parameters as strings"},\n      ]\n    }\n  }) { \n    id \n    runId\n  } \n}\n')),(0,r.kt)("h3",{id:"cancel-a-job"},"Cancel a job"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'mutation cancelJob {\n  updatePipelineJob(\n    where: { id: "your-job-id" }\n    data: { status: { set: "cancelled" } }\n  ) {\n    id\n  }\n}\n')),(0,r.kt)("h3",{id:"cancel-all-scheduled-jobs"},"Cancel all scheduled jobs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'mutation cancelScheduledJob {\n  updateManyPipelineJob(\n    where: { status: { equals: "scheduled" } }\n    data: { status: { set: "cancelled" } }\n  ) {\n    count\n  }\n}\n')),(0,r.kt)("h3",{id:"check-the-status-of-a-job"},"Check the status of a job"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'query checkStatus {\n  pipelineJob (where: {id: "your-job-id"}){\n    status\n  }\n}\n')),(0,r.kt)("h3",{id:"get-job-parameters"},"Get job parameters"),(0,r.kt)("p",null,"Get the list of parameters for a pipeline job "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"query nextJobs($id: String!) {\n  pipelineJobs(where: {id: {equals: $id}}) {\n    parameters {\n      key\n      value\n      id\n      pipelineJobId\n    }\n  }\n}\n")),(0,r.kt)("h3",{id:"detele-job-parameters"},"Detele job parameters"),(0,r.kt)("p",null,"Delete a parameter for a pipeline job"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"mutation($jobId: String!, $parameterId: String!) {\n  updatePipelineJob(where: {id: $jobId},\n  data: {\n    parameters: {disconnect: {id: $parameterId}}\n  }) {\n    id\n  }\n}\n")),(0,r.kt)("h3",{id:"update-job-parameters"},"Update job parameters"),(0,r.kt)("p",null,"Update the parameter key and value "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"mutation ($parameterId: String!, $keyValue: String, $valueValue: String) {\n  updateParameter(where: {id: $parameterId}, data: {\n    key: {set: $keyValue}\n    value: {set: $valueValue}\n  }) {\n    id\n  }\n}\n")))}_.isMDXComponent=!0}}]);